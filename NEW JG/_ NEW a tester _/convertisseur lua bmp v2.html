<!DOCTYPE html>
<html lang="fr">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Convertisseur Lua vers BMP</title>
    <script src="https://cdn.tailwindcss.com"></script>
    <style>
        body { font-family: 'Inter', sans-serif; }
        #manualSizeContainer.disabled { opacity: 0.5; pointer-events: none; }
    </style>
</head>
<body class="bg-gray-100 text-gray-800 p-4 md:p-8">

    <div class="max-w-4xl mx-auto bg-white p-6 rounded-lg shadow-lg">
        <h1 class="text-2xl font-bold mb-4 text-gray-900">Convertisseur de Dessin Lua vers Fichier BMP</h1>
        <p class="mb-6 text-gray-600">Collez votre code de dessin Lua (gère les variables x/y, calculs et commentaires), et générez un fichier .bmp.</p>

        <!-- Zone de configuration -->
        <div class="grid md:grid-cols-2 gap-6 mb-6">
            <div>
                <label for="luaCode" class="block text-sm font-medium text-gray-700 mb-1">1. Code de dessin Lua</label>
                <textarea id="luaCode" rows="15" class="w-full p-2 border border-gray-300 rounded-md shadow-sm focus:ring-indigo-500 focus:border-indigo-500 font-mono text-sm" placeholder="lcd.drawLine(10 + x, 10 + y, 20 + x, 20 + y)"></textarea>
            </div>
            <div>
                <h3 class="text-sm font-medium text-gray-700 mb-1">2. Paramètres de l'image</h3>
                <div class="flex items-center mb-4">
                    <input type="checkbox" id="autoSizeCheckbox" class="h-4 w-4 text-indigo-600 border-gray-300 rounded focus:ring-indigo-500" checked>
                    <label for="autoSizeCheckbox" class="ml-2 block text-sm text-gray-900">Déterminer la taille automatiquement</label>
                </div>
                <div id="manualSizeContainer" class="space-y-4">
                    <div>
                        <label for="bmpWidth" class="block text-xs font-medium text-gray-600">Largeur (pixels)</label>
                        <input type="number" id="bmpWidth" value="32" class="w-full p-2 border border-gray-300 rounded-md shadow-sm">
                    </div>
                    <div>
                        <label for="bmpHeight" class="block text-xs font-medium text-gray-600">Hauteur (pixels)</label>
                        <input type="number" id="bmpHeight" value="32" class="w-full p-2 border border-gray-300 rounded-md shadow-sm">
                    </div>
                </div>
                <div class="mt-4 grid grid-cols-2 gap-4">
                     <div>
                        <label for="offsetXVar" class="block text-xs font-medium text-gray-600">Valeur pour 'x'</label>
                        <input type="number" id="offsetXVar" value="0" class="w-full p-2 border border-gray-300 rounded-md shadow-sm">
                    </div>
                    <div>
                        <label for="offsetYVar" class="block text-xs font-medium text-gray-600">Valeur pour 'y'</label>
                        <input type="number" id="offsetYVar" value="0" class="w-full p-2 border border-gray-300 rounded-md shadow-sm">
                    </div>
                </div>
                <button id="generateBtn" class="mt-6 w-full bg-indigo-600 text-white font-bold py-2 px-4 rounded-md hover:bg-indigo-700 focus:outline-none focus:ring-2 focus:ring-offset-2 focus:ring-indigo-500">
                    Générer le fichier .BMP
                </button>
            </div>
        </div>

        <!-- Zone de prévisualisation et de téléchargement -->
        <div>
            <h3 class="text-sm font-medium text-gray-700 mb-2">3. Prévisualisation et Résultat</h3>
            <div class="flex items-center space-x-4">
                <div class="bg-gray-200 border border-gray-400 p-1 rounded-md" style="image-rendering: pixelated;">
                    <canvas id="previewCanvas" width="32" height="32"></canvas>
                </div>
                <div id="downloadLinkContainer" class="hidden">
                    <a id="downloadLink" class="bg-green-600 text-white font-bold py-2 px-4 rounded-md hover:bg-green-700">
                        Télécharger le .bmp
                    </a>
                </div>
            </div>
             <p id="dimensionsInfo" class="text-xs text-gray-500 mt-2"></p>
        </div>
    </div>

    <script>
        const generateBtn = document.getElementById('generateBtn');
        const luaCodeInput = document.getElementById('luaCode');
        const bmpWidthInput = document.getElementById('bmpWidth');
        const bmpHeightInput = document.getElementById('bmpHeight');
        const autoSizeCheckbox = document.getElementById('autoSizeCheckbox');
        const manualSizeContainer = document.getElementById('manualSizeContainer');
        const offsetXVarInput = document.getElementById('offsetXVar');
        const offsetYVarInput = document.getElementById('offsetYVar');
        const previewCanvas = document.getElementById('previewCanvas');
        const previewCtx = previewCanvas.getContext('2d');
        const downloadLinkContainer = document.getElementById('downloadLinkContainer');
        const downloadLink = document.getElementById('downloadLink');
        const dimensionsInfo = document.getElementById('dimensionsInfo');

        const TEMP_CANVAS_SIZE = 1024;

        previewCtx.imageSmoothingEnabled = false;

        function toggleAutoSize() {
            manualSizeContainer.classList.toggle('disabled', autoSizeCheckbox.checked);
        }
        autoSizeCheckbox.addEventListener('change', toggleAutoSize);
        toggleAutoSize();

        generateBtn.addEventListener('click', () => {
            const luaCode = luaCodeInput.value;
            const offsetX = parseInt(offsetXVarInput.value, 10) || 0;
            const offsetY = parseInt(offsetYVarInput.value, 10) || 0;

            const tempCanvas = document.createElement('canvas');
            tempCanvas.width = TEMP_CANVAS_SIZE;
            tempCanvas.height = TEMP_CANVAS_SIZE;
            const tempCtx = tempCanvas.getContext('2d');
            tempCtx.imageSmoothingEnabled = false;
            tempCtx.fillStyle = 'white';
            tempCtx.fillRect(0, 0, TEMP_CANVAS_SIZE, TEMP_CANVAS_SIZE);
            
            interpretAndDraw(luaCode, tempCtx, offsetX, offsetY);

            let finalCanvas;

            if (autoSizeCheckbox.checked) {
                const bounds = findBoundingBox(tempCanvas);
                if (!bounds) {
                    alert("Aucun pixel n'a été dessiné. Impossible de déterminer la taille.");
                    return;
                }
                
                const finalWidth = bounds.maxX - bounds.minX + 1;
                const finalHeight = bounds.maxY - bounds.minY + 1;
                dimensionsInfo.textContent = `Dimensions détectées : ${finalWidth} x ${finalHeight} pixels.`;

                finalCanvas = document.createElement('canvas');
                finalCanvas.width = finalWidth;
                finalCanvas.height = finalHeight;
                const finalCtx = finalCanvas.getContext('2d');
                finalCtx.imageSmoothingEnabled = false;
                finalCtx.drawImage(tempCanvas, bounds.minX, bounds.minY, finalWidth, finalHeight, 0, 0, finalWidth, finalHeight);
            } else {
                const width = parseInt(bmpWidthInput.value, 10);
                const height = parseInt(bmpHeightInput.value, 10);
                if (isNaN(width) || isNaN(height) || width <= 0 || height <= 0) {
                    alert("Veuillez entrer une largeur et une hauteur valides.");
                    return;
                }
                finalCanvas = document.createElement('canvas');
                finalCanvas.width = width;
                finalCanvas.height = height;
                finalCanvas.getContext('2d').drawImage(tempCanvas, 0, 0);
                dimensionsInfo.textContent = `Dimensions manuelles : ${width} x ${height} pixels.`;
            }

            previewCanvas.width = finalCanvas.width;
            previewCanvas.height = finalCanvas.height;
            previewCtx.drawImage(finalCanvas, 0, 0);

            const bmpDataUrl = canvasToBmp(finalCanvas);
            downloadLink.href = bmpDataUrl;
            downloadLink.download = `mon_icone_${finalCanvas.width}x${finalCanvas.height}.bmp`;
            downloadLinkContainer.classList.remove('hidden');
        });

        function findBoundingBox(canvas) {
            const ctx = canvas.getContext('2d');
            const imageData = ctx.getImageData(0, 0, canvas.width, canvas.height);
            const data = imageData.data;
            let minX = canvas.width, minY = canvas.height, maxX = -1, maxY = -1;

            for (let y = 0; y < canvas.height; y++) {
                for (let x = 0; x < canvas.width; x++) {
                    const i = (y * canvas.width + x) * 4;
                    if (data[i] < 255 || data[i+1] < 255 || data[i+2] < 255) {
                        if (x < minX) minX = x;
                        if (x > maxX) maxX = x;
                        if (y < minY) minY = y;
                        if (y > maxY) maxY = y;
                    }
                }
            }
            return maxX === -1 ? null : { minX, minY, maxX, maxY };
        }

        function interpretAndDraw(code, ctx, offsetX, offsetY) {
            const lines = code.split('\n');
            lines.forEach(line => {
                let processedLine = line;
                const commentIndex = processedLine.indexOf('--');
                if (commentIndex !== -1) {
                    processedLine = processedLine.substring(0, commentIndex);
                }
                const trimmedLine = processedLine.trim();
                
                if (trimmedLine === '') return;

                try {
                    const result = parseArgs(trimmedLine, offsetX, offsetY);
                    if (result.coords.length === 0) return;

                    if (trimmedLine.startsWith('lcd.drawPoint')) {
                        const [x, y] = result.coords;
                        if (result.erase) {
                            ctx.fillStyle = 'white';
                            ctx.fillRect(x, y, 1, 1);
                        } else {
                            const pixelData = ctx.getImageData(x, y, 1, 1).data;
                            const isBlack = pixelData[0] === 0;
                            ctx.fillStyle = isBlack ? 'white' : 'black';
                            ctx.fillRect(x, y, 1, 1);
                        }
                    } else if (trimmedLine.startsWith('lcd.drawLine')) {
                        ctx.fillStyle = result.erase ? 'white' : 'black';
                        const [x1, y1, x2, y2] = result.coords;
                        drawLine(ctx, x1, y1, x2, y2);
                    } else if (trimmedLine.startsWith('lcd.drawRectangle')) {
                        ctx.fillStyle = result.erase ? 'white' : 'black';
                        const [x, y, w, h] = result.coords;
                        drawLine(ctx, x, y, x + w - 1, y);
                        drawLine(ctx, x, y + h - 1, x + w - 1, y + h - 1);
                        drawLine(ctx, x, y, x, y + h - 1);
                        drawLine(ctx, x + w - 1, y, x + w - 1, y + h - 1);
                    } else if (trimmedLine.startsWith('lcd.drawFilledRectangle')) {
                        ctx.fillStyle = result.erase ? 'white' : 'black';
                        const [x, y, w, h] = result.coords;
                        ctx.fillRect(x, y, w, h);
                    }
                } catch(e) {
                    console.warn("Ligne ignorée ou erreur de parsing:", trimmedLine, e);
                }
            });
        }
        
        function parseArgs(line, offsetX, offsetY) {
             const content = line.substring(line.indexOf('(') + 1, line.lastIndexOf(')'));
             const parts = content.split(',');
             const result = { coords: [], erase: false };
             parts.forEach(part => {
                 let trimmed = part.trim();
                 if (trimmed.toUpperCase() === 'ERASE') {
                     result.erase = true;
                 } else {
                     try {
                         // *** CORRECTION : Remplace x et y par les valeurs d'offset ***
                         const expression = trimmed.replace(/\bx\b/g, `(${offsetX})`).replace(/\by\b/g, `(${offsetY})`);
                         const value = new Function('return ' + expression)();
                         if (typeof value === 'number' && isFinite(value)) {
                             result.coords.push(Math.round(value));
                         }
                     } catch (e) {
                         // Ignore les arguments non-valides comme SOLID, FORCE, etc.
                     }
                 }
             });
             return result;
        }

        function drawLine(ctx, x1, y1, x2, y2) {
            const dx = Math.abs(x2 - x1);
            const dy = -Math.abs(y2 - y1);
            const sx = x1 < x2 ? 1 : -1;
            const sy = y1 < y2 ? 1 : -1;
            let err = dx + dy;
            let x = x1;
            let y = y1;

            while (true) {
                ctx.fillRect(x, y, 1, 1);
                if (x === x2 && y === y2) break;
                const e2 = 2 * err;
                if (e2 >= dy) { err += dy; x += sx; }
                if (e2 <= dx) { err += dx; y += sy; }
            }
        }

        function canvasToBmp(canvas) {
            const w = canvas.width;
            const h = canvas.height;
            const imgData = canvas.getContext('2d').getImageData(0, 0, w, h);
            const data = imgData.data;
            const rowSize = Math.floor((24 * w + 31) / 32) * 4;
            const pixelArraySize = rowSize * h;
            const fileSize = 54 + pixelArraySize;
            const buffer = new ArrayBuffer(fileSize);
            const view = new DataView(buffer);
            view.setUint16(0, 0x4D42, true);
            view.setUint32(2, fileSize, true);
            view.setUint32(10, 54, true);
            view.setUint32(14, 40, true);
            view.setInt32(18, w, true);
            view.setInt32(22, h, true);
            view.setUint16(26, 1, true);
            view.setUint16(28, 24, true);
            view.setUint32(30, 0, true);
            view.setUint32(34, pixelArraySize, true);
            view.setInt32(38, 2835, true);
            view.setInt32(42, 2835, true);
            view.setUint32(46, 0, true);
            view.setUint32(50, 0, true);
            let offset = 54;
            for (let y = h - 1; y >= 0; y--) {
                for (let x = 0; x < w; x++) {
                    const i = (y * w + x) * 4;
                    view.setUint8(offset++, data[i + 2]);
                    view.setUint8(offset++, data[i + 1]);
                    view.setUint8(offset++, data[i]);
                }
                offset += (rowSize - (w * 3));
            }
            const blob = new Blob([view], { type: 'image/bmp' });
            return URL.createObjectURL(blob);
        }
    </script>
</body>
</html>
